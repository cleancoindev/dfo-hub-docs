{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"It's a me, dfohub","title":"Home"},{"location":"CONTRIBUTING/","text":"Contributing guidelines Table of Contents Table of Contents Coding Style Solidity JavaScript Python Documentation mkdocs Coding Style Solidity Solidity portions of the codebase adhere follow the official Solidity Styleguide JavaScript Python Python portions of the codebase follow standard PEP8 best practices. Python code must be formatted using the Black formatter using the provided settings. Documentation New addition to the codebase must be fully documented. JavaScript portions of the code should be annotated using JSDoc style docstrings. Solidity portions of the code should be fully annotated using NatSpec . Documentation is generated using py-solidity-docgen and rendered via mkdocs . py-solidity-docgen parses NatSpec and outputs .md files inside docs/md-build according to a pre-specified Jinja2 template. NOTE: Each .sol file should contain only one Interface or Contract . To build the documentation: yarn docs:build To serve the documentation yarn docs:serve mkdocs To install mkdocs and py-solidity-docgen Python must be installed in the system. pip install docs/requirements.in NOTE: Working inside a virtual environment is highly recommended!","title":"Contributing"},{"location":"CONTRIBUTING/#contributing-guidelines","text":"","title":"Contributing guidelines"},{"location":"CONTRIBUTING/#table-of-contents","text":"Table of Contents Coding Style Solidity JavaScript Python Documentation mkdocs","title":"Table of Contents"},{"location":"CONTRIBUTING/#coding-style","text":"","title":"Coding Style"},{"location":"CONTRIBUTING/#solidity","text":"Solidity portions of the codebase adhere follow the official Solidity Styleguide","title":"Solidity"},{"location":"CONTRIBUTING/#javascript","text":"","title":"JavaScript"},{"location":"CONTRIBUTING/#python","text":"Python portions of the codebase follow standard PEP8 best practices. Python code must be formatted using the Black formatter using the provided settings.","title":"Python"},{"location":"CONTRIBUTING/#documentation","text":"New addition to the codebase must be fully documented. JavaScript portions of the code should be annotated using JSDoc style docstrings. Solidity portions of the code should be fully annotated using NatSpec . Documentation is generated using py-solidity-docgen and rendered via mkdocs . py-solidity-docgen parses NatSpec and outputs .md files inside docs/md-build according to a pre-specified Jinja2 template. NOTE: Each .sol file should contain only one Interface or Contract . To build the documentation: yarn docs:build To serve the documentation yarn docs:serve","title":"Documentation"},{"location":"CONTRIBUTING/#mkdocs","text":"To install mkdocs and py-solidity-docgen Python must be installed in the system. pip install docs/requirements.in NOTE: Working inside a virtual environment is highly recommended!","title":"mkdocs"},{"location":"contracts/DeployDFO/","text":"Contract DeployDFO Path: contracts/DeployDFO.sol Version: 1 Title: Deploy the DFO This specific DFOHub Functionality is called as the last step of the creation of a DFO. It clones the original DFOHub Proxy contract and sets up all the other delegate contracts (Voting Token, State Holder, Governance Rules, Functionalities, and Proposals Manager). The Functionality checks if DFOHub received the correct amount of tokens needed for the creation. After the init operation on the already-created Proxy, DFOHub transfers the expected amount of tokens (e.g. if Governance type is Community Driven, the new DFO expected to receive the chosen amount of voting tokens set to pay rewards for successful surveys). As a final step, this Functionality also sets up the chosen ENS for this DFO. Methods constructor Constructor for the contract Params metadataLink : Link to the metadata of all the microservice information deployDFO(address,uint256,address,address,address,address,address,address,address,string) Actual deploy logic for the DFO Params doubleProxyAddress : Address of the DoubleProxy ens : String encoding the ENS subdomain to use for the DFO being created mvdFunctionalitiesManagerAddress : Address of the FunctionalitiesManager mvdFunctionalityModelsManagerAddress : Address of the mvdFunctionalityProposalManagerAddress : Address of the FunctionalityProposalManager sender : Address of the caller stateHolderAddress : Address of the stateHolder component votingToken : Address of the voting token walletAddress : Wallet of the new DFO Returns proxy : Address of the Proxy getMetadataLink() GETTER for the metadataLink Returns metadataLink : Link to the metadata onStart(address,address) Each Microservice needs to implement its own logic for handling what happens when it's added or removed from a a DFO onStart is one of this mandatory functions. onStart is triggered when a microservice is added. The method body can be left blank (i.e. you don't need any special startup/teardown logic) The only strict requirement is for the method to be there. onStop(address) Each Microservice needs to implement its own logic for handling what happens when it's added or removed from a a DFO onStop is one of this mandatory functions. onStop is triggered when a microservice is removed. The method body can be left blank (i.e. you don't need any special startup/teardown logic) The only strict requirement is for the method to be there.","title":"DeployDFO"},{"location":"contracts/DeployDFO/#contract-deploydfo","text":"Path: contracts/DeployDFO.sol Version: 1 Title: Deploy the DFO This specific DFOHub Functionality is called as the last step of the creation of a DFO. It clones the original DFOHub Proxy contract and sets up all the other delegate contracts (Voting Token, State Holder, Governance Rules, Functionalities, and Proposals Manager). The Functionality checks if DFOHub received the correct amount of tokens needed for the creation. After the init operation on the already-created Proxy, DFOHub transfers the expected amount of tokens (e.g. if Governance type is Community Driven, the new DFO expected to receive the chosen amount of voting tokens set to pay rewards for successful surveys). As a final step, this Functionality also sets up the chosen ENS for this DFO.","title":"Contract DeployDFO"},{"location":"contracts/DeployDFO/#methods","text":"","title":"Methods"},{"location":"contracts/DeployDFO/#constructor","text":"Constructor for the contract","title":"constructor"},{"location":"contracts/DeployDFO/#params","text":"metadataLink : Link to the metadata of all the microservice information","title":"Params"},{"location":"contracts/DeployDFO/#deploydfoaddressuint256addressaddressaddressaddressaddressaddressaddressstring","text":"Actual deploy logic for the DFO","title":"deployDFO(address,uint256,address,address,address,address,address,address,address,string)"},{"location":"contracts/DeployDFO/#params_1","text":"doubleProxyAddress : Address of the DoubleProxy ens : String encoding the ENS subdomain to use for the DFO being created mvdFunctionalitiesManagerAddress : Address of the FunctionalitiesManager mvdFunctionalityModelsManagerAddress : Address of the mvdFunctionalityProposalManagerAddress : Address of the FunctionalityProposalManager sender : Address of the caller stateHolderAddress : Address of the stateHolder component votingToken : Address of the voting token walletAddress : Wallet of the new DFO","title":"Params"},{"location":"contracts/DeployDFO/#returns","text":"proxy : Address of the Proxy","title":"Returns"},{"location":"contracts/DeployDFO/#getmetadatalink","text":"GETTER for the metadataLink","title":"getMetadataLink()"},{"location":"contracts/DeployDFO/#returns_1","text":"metadataLink : Link to the metadata","title":"Returns"},{"location":"contracts/DeployDFO/#onstartaddressaddress","text":"Each Microservice needs to implement its own logic for handling what happens when it's added or removed from a a DFO onStart is one of this mandatory functions. onStart is triggered when a microservice is added. The method body can be left blank (i.e. you don't need any special startup/teardown logic) The only strict requirement is for the method to be there.","title":"onStart(address,address)"},{"location":"contracts/DeployDFO/#onstopaddress","text":"Each Microservice needs to implement its own logic for handling what happens when it's added or removed from a a DFO onStop is one of this mandatory functions. onStop is triggered when a microservice is removed. The method body can be left blank (i.e. you don't need any special startup/teardown logic) The only strict requirement is for the method to be there.","title":"onStop(address)"},{"location":"contracts/DeployGovernanceRules/","text":"Contract DeployGovernanceRules Path: contracts/DeployGovernanceRules.sol Version: 1 Title: Deploy Governance Rules This Microservice contains all the code useful to create the FunctionalitiesManager Core Contract. The logic clones the original dfohub FunctionalitiesManager contract code and adds to it all the mandatory Functionalities. Also, it can optionally insert other side-functionalities like the Survey Quorum, the Votes Hard Cap, the minimum Survey Staking amount, or the reward amount for each successful Survey. Methods constructor Constructor for the contract Params metadataLink : Link to the metadata of all the microservice information deployGovernanceRules(address,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256) Deploy the Governance Rules cloning the original core one and modify it according to the desired functionalities/configurations Params ``: @param minimumBlockNumber Amount of blocks for the duration of a proposal emergencyBlockNumber : Amount of blocks for the duration of an EmergencyProposal emergencyStaking : Emergency Staking quorum : Required quorum for a proposal to be accepted sender : Address of the caller surveyMaxCap : Amount of voting tokens needed to reach the max-cap on a proposal surveyMinStake : The minimum of Token Staked needed to create a new Proposal. surveySingleReward : The amount of Voting Tokens set as a reward to the issuer for every Accepted Proposal paid automatically by the DFO Wallet. Returns mvdFunctionalitiesManager : The newly created Functionalities Manager getMetadataLink() GETTER for the metadataLink Returns metadataLink : Link to the metadata onStart(address,address) Each Microservice needs to implement its own logic for handling what happens when it's added or removed from a a DFO onStart is one of this mandatory functions. onStart is triggered when a microservice is added. The method body can be left blank (i.e. you don't need any special startup/teardown logic) The only strict requirement is for the method to be there. onStop(address) Each Microservice needs to implement its own logic for handling what happens when it's added or removed from a a DFO onStop is one of this mandatory functions. onStop is triggered when a microservice is removed. The method body can be left blank (i.e. you don't need any special startup/teardown logic) The only strict requirement is for the method to be there.","title":"DeployGovernanceRules"},{"location":"contracts/DeployGovernanceRules/#contract-deploygovernancerules","text":"Path: contracts/DeployGovernanceRules.sol Version: 1 Title: Deploy Governance Rules This Microservice contains all the code useful to create the FunctionalitiesManager Core Contract. The logic clones the original dfohub FunctionalitiesManager contract code and adds to it all the mandatory Functionalities. Also, it can optionally insert other side-functionalities like the Survey Quorum, the Votes Hard Cap, the minimum Survey Staking amount, or the reward amount for each successful Survey.","title":"Contract DeployGovernanceRules"},{"location":"contracts/DeployGovernanceRules/#methods","text":"","title":"Methods"},{"location":"contracts/DeployGovernanceRules/#constructor","text":"Constructor for the contract","title":"constructor"},{"location":"contracts/DeployGovernanceRules/#params","text":"metadataLink : Link to the metadata of all the microservice information","title":"Params"},{"location":"contracts/DeployGovernanceRules/#deploygovernancerulesaddressuint256uint256uint256uint256uint256uint256uint256uint256","text":"Deploy the Governance Rules cloning the original core one and modify it according to the desired functionalities/configurations","title":"deployGovernanceRules(address,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256)"},{"location":"contracts/DeployGovernanceRules/#params_1","text":"``: @param minimumBlockNumber Amount of blocks for the duration of a proposal emergencyBlockNumber : Amount of blocks for the duration of an EmergencyProposal emergencyStaking : Emergency Staking quorum : Required quorum for a proposal to be accepted sender : Address of the caller surveyMaxCap : Amount of voting tokens needed to reach the max-cap on a proposal surveyMinStake : The minimum of Token Staked needed to create a new Proposal. surveySingleReward : The amount of Voting Tokens set as a reward to the issuer for every Accepted Proposal paid automatically by the DFO Wallet.","title":"Params"},{"location":"contracts/DeployGovernanceRules/#returns","text":"mvdFunctionalitiesManager : The newly created Functionalities Manager","title":"Returns"},{"location":"contracts/DeployGovernanceRules/#getmetadatalink","text":"GETTER for the metadataLink","title":"getMetadataLink()"},{"location":"contracts/DeployGovernanceRules/#returns_1","text":"metadataLink : Link to the metadata","title":"Returns"},{"location":"contracts/DeployGovernanceRules/#onstartaddressaddress","text":"Each Microservice needs to implement its own logic for handling what happens when it's added or removed from a a DFO onStart is one of this mandatory functions. onStart is triggered when a microservice is added. The method body can be left blank (i.e. you don't need any special startup/teardown logic) The only strict requirement is for the method to be there.","title":"onStart(address,address)"},{"location":"contracts/DeployGovernanceRules/#onstopaddress","text":"Each Microservice needs to implement its own logic for handling what happens when it's added or removed from a a DFO onStop is one of this mandatory functions. onStop is triggered when a microservice is removed. The method body can be left blank (i.e. you don't need any special startup/teardown logic) The only strict requirement is for the method to be there.","title":"onStop(address)"},{"location":"contracts/DeployVotingToken/","text":"Contract DeployVotingToken Path: contracts/DeployVotingToken.sol Version: 1 Title: Voting Token Creation. This specific DFOHub functionality is called during the new DFO creation. It initialized 3 DFO delegates cloning them from the original DFOHub ones: Voting Token, State Holder, Well-Known Functionalities Manager. Voting Token amount is split between DFOHub (calculating the correct amount through the proper functionality) and the survey proposer. After its initialization, StateHolder is filled with a standard index page and an additional voting token amount (if any). Methods constructor Constructor for the contract Params metadataLink : Link to the metadata of all the microservice information deployVotingToken(address,uint256,string,string,uint256,uint256) Deploy the voting token Params ``: @param name Name of the voting token additionalAmount : Token supply that will be left locked inside the DFO after creation sender : Address of the Caller symbol : Ticker Symbol for the voting token totalSupply : Total Supply of the voting token Returns mvdFunctionalityModelsManagerAddress : Address of the FunctionalityModelsManager stateHolderAddress : Address of the StateHolder votingToken : Address of the newly deployed voting token getMetadataLink() GETTER for the metadataLink Returns metadataLink : Link to the metadata onStart(address,address) Each Microservice needs to implement its own logic for handling what happens when it's added or removed from a a DFO onStart is one of this mandatory functions. onStart is triggered when a microservice is added. The method body can be left blank (i.e. you don't need any special startup/teardown logic) The only strict requirement is for the method to be there. onStop(address) Each Microservice needs to implement its own logic for handling what happens when it's added or removed from a a DFO onStop is one of this mandatory functions. onStop is triggered when a microservice is removed. The method body can be left blank (i.e. you don't need any special startup/teardown logic) The only strict requirement is for the method to be there.","title":"DeployVotingToken"},{"location":"contracts/DeployVotingToken/#contract-deployvotingtoken","text":"Path: contracts/DeployVotingToken.sol Version: 1 Title: Voting Token Creation. This specific DFOHub functionality is called during the new DFO creation. It initialized 3 DFO delegates cloning them from the original DFOHub ones: Voting Token, State Holder, Well-Known Functionalities Manager. Voting Token amount is split between DFOHub (calculating the correct amount through the proper functionality) and the survey proposer. After its initialization, StateHolder is filled with a standard index page and an additional voting token amount (if any).","title":"Contract DeployVotingToken"},{"location":"contracts/DeployVotingToken/#methods","text":"","title":"Methods"},{"location":"contracts/DeployVotingToken/#constructor","text":"Constructor for the contract","title":"constructor"},{"location":"contracts/DeployVotingToken/#params","text":"metadataLink : Link to the metadata of all the microservice information","title":"Params"},{"location":"contracts/DeployVotingToken/#deployvotingtokenaddressuint256stringstringuint256uint256","text":"Deploy the voting token","title":"deployVotingToken(address,uint256,string,string,uint256,uint256)"},{"location":"contracts/DeployVotingToken/#params_1","text":"``: @param name Name of the voting token additionalAmount : Token supply that will be left locked inside the DFO after creation sender : Address of the Caller symbol : Ticker Symbol for the voting token totalSupply : Total Supply of the voting token","title":"Params"},{"location":"contracts/DeployVotingToken/#returns","text":"mvdFunctionalityModelsManagerAddress : Address of the FunctionalityModelsManager stateHolderAddress : Address of the StateHolder votingToken : Address of the newly deployed voting token","title":"Returns"},{"location":"contracts/DeployVotingToken/#getmetadatalink","text":"GETTER for the metadataLink","title":"getMetadataLink()"},{"location":"contracts/DeployVotingToken/#returns_1","text":"metadataLink : Link to the metadata","title":"Returns"},{"location":"contracts/DeployVotingToken/#onstartaddressaddress","text":"Each Microservice needs to implement its own logic for handling what happens when it's added or removed from a a DFO onStart is one of this mandatory functions. onStart is triggered when a microservice is added. The method body can be left blank (i.e. you don't need any special startup/teardown logic) The only strict requirement is for the method to be there.","title":"onStart(address,address)"},{"location":"contracts/DeployVotingToken/#onstopaddress","text":"Each Microservice needs to implement its own logic for handling what happens when it's added or removed from a a DFO onStop is one of this mandatory functions. onStop is triggered when a microservice is removed. The method body can be left blank (i.e. you don't need any special startup/teardown logic) The only strict requirement is for the method to be there.","title":"onStop(address)"},{"location":"contracts/GetEmergencySurveyStakingFunctionality/","text":"Contract GetEmergencySurveyStakingFunctionality Path: contracts/GetEmergencySurveyStakingFunctionality.sol Version: 1 Title: Emergency Survey staking provider. One of the 4 well-known read-only mandatory Functionalities every DFO needs. The logic is for general purpose so that every DFO can use it as a Stateless Microservice. It provides the amount of Voting Tokens every proposer must stake to start a new emergency Survey Proposal. Methods constructor Constructor for the contract Params metadataLink : Link to the metadata of all the microservice information getEmergencySurveyStaking() GETTER for the EmergencySurvey staking Returns value : Amount of token that must be be staked for the EmergencySurvey to start getMetadataLink() GETTER for the metadataLink Returns metadataLink : Link to the metadata onStart(address,address) Each Microservice needs to implement its own logic for handling what happens when it's added or removed from a a DFO onStart is one of this mandatory functions. onStart is triggered when a microservice is added. The method body can be left blank (i.e. you don't need any special startup/teardown logic) The only strict requirement is for the method to be there. onStop(address) Each Microservice needs to implement its own logic for handling what happens when it's added or removed from a a DFO onStop is one of this mandatory functions. onStop is triggered when a microservice is removed. The method body can be left blank (i.e. you don't need any special startup/teardown logic) The only strict requirement is for the method to be there.","title":"GetEmergencySurveyStakingFunctionality"},{"location":"contracts/GetEmergencySurveyStakingFunctionality/#contract-getemergencysurveystakingfunctionality","text":"Path: contracts/GetEmergencySurveyStakingFunctionality.sol Version: 1 Title: Emergency Survey staking provider. One of the 4 well-known read-only mandatory Functionalities every DFO needs. The logic is for general purpose so that every DFO can use it as a Stateless Microservice. It provides the amount of Voting Tokens every proposer must stake to start a new emergency Survey Proposal.","title":"Contract GetEmergencySurveyStakingFunctionality"},{"location":"contracts/GetEmergencySurveyStakingFunctionality/#methods","text":"","title":"Methods"},{"location":"contracts/GetEmergencySurveyStakingFunctionality/#constructor","text":"Constructor for the contract","title":"constructor"},{"location":"contracts/GetEmergencySurveyStakingFunctionality/#params","text":"metadataLink : Link to the metadata of all the microservice information","title":"Params"},{"location":"contracts/GetEmergencySurveyStakingFunctionality/#getemergencysurveystaking","text":"GETTER for the EmergencySurvey staking","title":"getEmergencySurveyStaking()"},{"location":"contracts/GetEmergencySurveyStakingFunctionality/#returns","text":"value : Amount of token that must be be staked for the EmergencySurvey to start","title":"Returns"},{"location":"contracts/GetEmergencySurveyStakingFunctionality/#getmetadatalink","text":"GETTER for the metadataLink","title":"getMetadataLink()"},{"location":"contracts/GetEmergencySurveyStakingFunctionality/#returns_1","text":"metadataLink : Link to the metadata","title":"Returns"},{"location":"contracts/GetEmergencySurveyStakingFunctionality/#onstartaddressaddress","text":"Each Microservice needs to implement its own logic for handling what happens when it's added or removed from a a DFO onStart is one of this mandatory functions. onStart is triggered when a microservice is added. The method body can be left blank (i.e. you don't need any special startup/teardown logic) The only strict requirement is for the method to be there.","title":"onStart(address,address)"},{"location":"contracts/GetEmergencySurveyStakingFunctionality/#onstopaddress","text":"Each Microservice needs to implement its own logic for handling what happens when it's added or removed from a a DFO onStop is one of this mandatory functions. onStop is triggered when a microservice is removed. The method body can be left blank (i.e. you don't need any special startup/teardown logic) The only strict requirement is for the method to be there.","title":"onStop(address)"},{"location":"contracts/GetMinimumBlockNumberForEmergencySurveyFunctionality/","text":"Contract GetMinimumBlockNumberForEmergencySurveyFunctionality Path: contracts/GetMinimumBlockNumberForEmergencySurveyFunctionality.sol Version: 1 Title: Emergency Survey duration provider. One of the 4 well-known read-only mandatory Functionalities every DFO needs. The logic is for general purpose so that every DFO can use it as a Stateless Microservice. It provides the time duration (expected in blocks) of every emergency Survey Proposal. Methods constructor Contract constructor Params metadataLink : Link to the metadata of all the microservice information value : Amount of blocks for the duration of the EmergencySurvey proposal getMetadataLink() GETTER for the metadataLink Returns metadataLink : Link to the metadata getMinimumBlockNumberForEmergencySurvey() GETTER for the block duration of emergency proposals Returns _0 : value Amount of block indicating the duration of emergency proposals onStart(address,address) Each Microservice needs to implement its own logic for handling what happens when it's added or removed from a a DFO onStart is one of this mandatory functions. onStart is triggered when a microservice is added. The method body can be left blank (i.e. you don't need any special startup/teardown logic) The only strict requirement is for the method to be there. onStop(address) Each Microservice needs to implement its own logic for handling what happens when it's added or removed from a a DFO onStop is one of this mandatory functions. onStop is triggered when a microservice is removed. The method body can be left blank (i.e. you don't need any special startup/teardown logic) The only strict requirement is for the method to be there.","title":"GetMinimumBlockNumberForEmergencySurveyFunctionality"},{"location":"contracts/GetMinimumBlockNumberForEmergencySurveyFunctionality/#contract-getminimumblocknumberforemergencysurveyfunctionality","text":"Path: contracts/GetMinimumBlockNumberForEmergencySurveyFunctionality.sol Version: 1 Title: Emergency Survey duration provider. One of the 4 well-known read-only mandatory Functionalities every DFO needs. The logic is for general purpose so that every DFO can use it as a Stateless Microservice. It provides the time duration (expected in blocks) of every emergency Survey Proposal.","title":"Contract GetMinimumBlockNumberForEmergencySurveyFunctionality"},{"location":"contracts/GetMinimumBlockNumberForEmergencySurveyFunctionality/#methods","text":"","title":"Methods"},{"location":"contracts/GetMinimumBlockNumberForEmergencySurveyFunctionality/#constructor","text":"Contract constructor","title":"constructor"},{"location":"contracts/GetMinimumBlockNumberForEmergencySurveyFunctionality/#params","text":"metadataLink : Link to the metadata of all the microservice information value : Amount of blocks for the duration of the EmergencySurvey proposal","title":"Params"},{"location":"contracts/GetMinimumBlockNumberForEmergencySurveyFunctionality/#getmetadatalink","text":"GETTER for the metadataLink","title":"getMetadataLink()"},{"location":"contracts/GetMinimumBlockNumberForEmergencySurveyFunctionality/#returns","text":"metadataLink : Link to the metadata","title":"Returns"},{"location":"contracts/GetMinimumBlockNumberForEmergencySurveyFunctionality/#getminimumblocknumberforemergencysurvey","text":"GETTER for the block duration of emergency proposals","title":"getMinimumBlockNumberForEmergencySurvey()"},{"location":"contracts/GetMinimumBlockNumberForEmergencySurveyFunctionality/#returns_1","text":"_0 : value Amount of block indicating the duration of emergency proposals","title":"Returns"},{"location":"contracts/GetMinimumBlockNumberForEmergencySurveyFunctionality/#onstartaddressaddress","text":"Each Microservice needs to implement its own logic for handling what happens when it's added or removed from a a DFO onStart is one of this mandatory functions. onStart is triggered when a microservice is added. The method body can be left blank (i.e. you don't need any special startup/teardown logic) The only strict requirement is for the method to be there.","title":"onStart(address,address)"},{"location":"contracts/GetMinimumBlockNumberForEmergencySurveyFunctionality/#onstopaddress","text":"Each Microservice needs to implement its own logic for handling what happens when it's added or removed from a a DFO onStop is one of this mandatory functions. onStop is triggered when a microservice is removed. The method body can be left blank (i.e. you don't need any special startup/teardown logic) The only strict requirement is for the method to be there.","title":"onStop(address)"},{"location":"contracts/GetMinimumBlockNumberForSurveyFunctionality/","text":"Contract GetMinimumBlockNumberForSurveyFunctionality Path: contracts/GetMinimumBlockNumberForSurveyFunctionality.sol Version: 1 Title: Normal Survey duration provider. One of the 4 well-known read-only mandatory Functionalities every DFO needs. The logic is for general purpose so that every DFO can use it as a Stateless Microservice. It provides the time duration (expected in blocks) of every normal Survey Proposal. Methods constructor Contract constructor Params metadataLink : Link to the metadata of all the microservice information value : Amount of blocks for the duration of the standard proposal getMetadataLink() GETTER for the metadataLink Returns metadataLink : Link to the metadata getMinimumBlockNumberForSurvey() GETTER for the block duration of the proposal Returns value : Amount of block indicating the duration of proposals onStart(address,address) Each Microservice needs to implement its own logic for handling what happens when it's added or removed from a a DFO onStart is one of this mandatory functions. onStart is triggered when a microservice is added. The method body can be left blank (i.e. you don't need any special startup/teardown logic) The only strict requirement is for the method to be there. onStop(address) Each Microservice needs to implement its own logic for handling what happens when it's added or removed from a a DFO onStop is one of this mandatory functions. onStop is triggered when a microservice is removed. The method body can be left blank (i.e. you don't need any special startup/teardown logic) The only strict requirement is for the method to be there.","title":"GetMinimumBlockNumberForSurveyFunctionality"},{"location":"contracts/GetMinimumBlockNumberForSurveyFunctionality/#contract-getminimumblocknumberforsurveyfunctionality","text":"Path: contracts/GetMinimumBlockNumberForSurveyFunctionality.sol Version: 1 Title: Normal Survey duration provider. One of the 4 well-known read-only mandatory Functionalities every DFO needs. The logic is for general purpose so that every DFO can use it as a Stateless Microservice. It provides the time duration (expected in blocks) of every normal Survey Proposal.","title":"Contract GetMinimumBlockNumberForSurveyFunctionality"},{"location":"contracts/GetMinimumBlockNumberForSurveyFunctionality/#methods","text":"","title":"Methods"},{"location":"contracts/GetMinimumBlockNumberForSurveyFunctionality/#constructor","text":"Contract constructor","title":"constructor"},{"location":"contracts/GetMinimumBlockNumberForSurveyFunctionality/#params","text":"metadataLink : Link to the metadata of all the microservice information value : Amount of blocks for the duration of the standard proposal","title":"Params"},{"location":"contracts/GetMinimumBlockNumberForSurveyFunctionality/#getmetadatalink","text":"GETTER for the metadataLink","title":"getMetadataLink()"},{"location":"contracts/GetMinimumBlockNumberForSurveyFunctionality/#returns","text":"metadataLink : Link to the metadata","title":"Returns"},{"location":"contracts/GetMinimumBlockNumberForSurveyFunctionality/#getminimumblocknumberforsurvey","text":"GETTER for the block duration of the proposal","title":"getMinimumBlockNumberForSurvey()"},{"location":"contracts/GetMinimumBlockNumberForSurveyFunctionality/#returns_1","text":"value : Amount of block indicating the duration of proposals","title":"Returns"},{"location":"contracts/GetMinimumBlockNumberForSurveyFunctionality/#onstartaddressaddress","text":"Each Microservice needs to implement its own logic for handling what happens when it's added or removed from a a DFO onStart is one of this mandatory functions. onStart is triggered when a microservice is added. The method body can be left blank (i.e. you don't need any special startup/teardown logic) The only strict requirement is for the method to be there.","title":"onStart(address,address)"},{"location":"contracts/GetMinimumBlockNumberForSurveyFunctionality/#onstopaddress","text":"Each Microservice needs to implement its own logic for handling what happens when it's added or removed from a a DFO onStop is one of this mandatory functions. onStop is triggered when a microservice is removed. The method body can be left blank (i.e. you don't need any special startup/teardown logic) The only strict requirement is for the method to be there.","title":"onStop(address)"},{"location":"contracts/SurveyResultValidator/","text":"Contract SurveyResultValidator Path: contracts/SurveyResultValidator.sol Version: 1 Title: Survey Result validator. One of the 4 well-known read-only mandatory Functionalities every DFO needs. The logic of this functionality is for general purpose so that every DFO can use it as a Stateless Microservice. This logic can provide a Proposal (partial) situation even while the Proposal is still running. It contains the logic to provide the survey result. If the proposer has not staked a minimum amount of Voting Tokens (Decided by the DFO Governance Rules), the Proposal is considered failed by design, regardless of its number of votes. If the DFO Governance Rules provide a minimum quorum of Voting Tokens and it is not reached, regardless of accepts or refuses, the Proposal is considered failed. If the two rules described above are respected or bypassed, the Proposal is to be considered valid if and only if the accept votes are higher than the refuses. Methods checkSurveyResult(address) Check the result of a survey. It returns false if the proposal is either invalid or if it does not reach the quorum. Params proposalAddress : Address of the proposal to check Returns result : Boolean flag indicating wether the proposal was successful or not constructor Constructor for the contract Params metadataLink : Link to the metadata of all the microservice information getMetadataLink() GETTER for the metadataLink Returns metadataLink : Link to the metadata onStart(address,address) Each Microservice needs to implement its own logic for handling what happens when it's added or removed from a a DFO onStart is one of this mandatory functions. onStart is triggered when a microservice is added. The method body can be left blank (i.e. you don't need any special startup/teardown logic) The only strict requirement is for the method to be there. onStop(address) Each Microservice needs to implement its own logic for handling what happens when it's added or removed from a a DFO onStop is one of this mandatory functions. onStop is triggered when a microservice is removed. The method body can be left blank (i.e. you don't need any special startup/teardown logic) The only strict requirement is for the method to be there.","title":"SurveyResultValidator"},{"location":"contracts/SurveyResultValidator/#contract-surveyresultvalidator","text":"Path: contracts/SurveyResultValidator.sol Version: 1 Title: Survey Result validator. One of the 4 well-known read-only mandatory Functionalities every DFO needs. The logic of this functionality is for general purpose so that every DFO can use it as a Stateless Microservice. This logic can provide a Proposal (partial) situation even while the Proposal is still running. It contains the logic to provide the survey result. If the proposer has not staked a minimum amount of Voting Tokens (Decided by the DFO Governance Rules), the Proposal is considered failed by design, regardless of its number of votes. If the DFO Governance Rules provide a minimum quorum of Voting Tokens and it is not reached, regardless of accepts or refuses, the Proposal is considered failed. If the two rules described above are respected or bypassed, the Proposal is to be considered valid if and only if the accept votes are higher than the refuses.","title":"Contract SurveyResultValidator"},{"location":"contracts/SurveyResultValidator/#methods","text":"","title":"Methods"},{"location":"contracts/SurveyResultValidator/#checksurveyresultaddress","text":"Check the result of a survey. It returns false if the proposal is either invalid or if it does not reach the quorum.","title":"checkSurveyResult(address)"},{"location":"contracts/SurveyResultValidator/#params","text":"proposalAddress : Address of the proposal to check","title":"Params"},{"location":"contracts/SurveyResultValidator/#returns","text":"result : Boolean flag indicating wether the proposal was successful or not","title":"Returns"},{"location":"contracts/SurveyResultValidator/#constructor","text":"Constructor for the contract","title":"constructor"},{"location":"contracts/SurveyResultValidator/#params_1","text":"metadataLink : Link to the metadata of all the microservice information","title":"Params"},{"location":"contracts/SurveyResultValidator/#getmetadatalink","text":"GETTER for the metadataLink","title":"getMetadataLink()"},{"location":"contracts/SurveyResultValidator/#returns_1","text":"metadataLink : Link to the metadata","title":"Returns"},{"location":"contracts/SurveyResultValidator/#onstartaddressaddress","text":"Each Microservice needs to implement its own logic for handling what happens when it's added or removed from a a DFO onStart is one of this mandatory functions. onStart is triggered when a microservice is added. The method body can be left blank (i.e. you don't need any special startup/teardown logic) The only strict requirement is for the method to be there.","title":"onStart(address,address)"},{"location":"contracts/SurveyResultValidator/#onstopaddress","text":"Each Microservice needs to implement its own logic for handling what happens when it's added or removed from a a DFO onStop is one of this mandatory functions. onStop is triggered when a microservice is removed. The method body can be left blank (i.e. you don't need any special startup/teardown logic) The only strict requirement is for the method to be there.","title":"onStop(address)"},{"location":"contracts/VotingTokenAmountForHub/","text":"Contract VotingTokenAmountForHub Path: contracts/VotingTokenAmountForHub.sol Version: 1 Title: Generation Fee Contract Once a DFO is created, it automatically sends a percentage of its Voting Tokens to the DFOHub Community Wallet as a percentage of the total supply. This function calculates the correct amount to send to DFOHub. The Token supply earned by DFOhub is driven by DFOhub token holders. Methods calculate(uint256) Calculate generation fee Params total : Total supply of the voting token Returns generationFee : Computed generation fee constructor Constructor for the contract Params metadataLink : Link to the metadata of all the microservice information getMetadataLink() GETTER for the metadataLink Returns metadataLink : Link to the metadata onStart(address,address) Each Microservice needs to implement its own logic for handling what happens when it's added or removed from a a DFO onStart is one of this mandatory functions. onStart is triggered when a microservice is added. The method body can be left blank (i.e. you don't need any special startup/teardown logic) The only strict requirement is for the method to be there. onStop(address) Each Microservice needs to implement its own logic for handling what happens when it's added or removed from a a DFO onStop is one of this mandatory functions. onStop is triggered when a microservice is removed. The method body can be left blank (i.e. you don't need any special startup/teardown logic) The only strict requirement is for the method to be there.","title":"VotingTokenAmountForHub"},{"location":"contracts/VotingTokenAmountForHub/#contract-votingtokenamountforhub","text":"Path: contracts/VotingTokenAmountForHub.sol Version: 1 Title: Generation Fee Contract Once a DFO is created, it automatically sends a percentage of its Voting Tokens to the DFOHub Community Wallet as a percentage of the total supply. This function calculates the correct amount to send to DFOHub. The Token supply earned by DFOhub is driven by DFOhub token holders.","title":"Contract VotingTokenAmountForHub"},{"location":"contracts/VotingTokenAmountForHub/#methods","text":"","title":"Methods"},{"location":"contracts/VotingTokenAmountForHub/#calculateuint256","text":"Calculate generation fee","title":"calculate(uint256)"},{"location":"contracts/VotingTokenAmountForHub/#params","text":"total : Total supply of the voting token","title":"Params"},{"location":"contracts/VotingTokenAmountForHub/#returns","text":"generationFee : Computed generation fee","title":"Returns"},{"location":"contracts/VotingTokenAmountForHub/#constructor","text":"Constructor for the contract","title":"constructor"},{"location":"contracts/VotingTokenAmountForHub/#params_1","text":"metadataLink : Link to the metadata of all the microservice information","title":"Params"},{"location":"contracts/VotingTokenAmountForHub/#getmetadatalink","text":"GETTER for the metadataLink","title":"getMetadataLink()"},{"location":"contracts/VotingTokenAmountForHub/#returns_1","text":"metadataLink : Link to the metadata","title":"Returns"},{"location":"contracts/VotingTokenAmountForHub/#onstartaddressaddress","text":"Each Microservice needs to implement its own logic for handling what happens when it's added or removed from a a DFO onStart is one of this mandatory functions. onStart is triggered when a microservice is added. The method body can be left blank (i.e. you don't need any special startup/teardown logic) The only strict requirement is for the method to be there.","title":"onStart(address,address)"},{"location":"contracts/VotingTokenAmountForHub/#onstopaddress","text":"Each Microservice needs to implement its own logic for handling what happens when it's added or removed from a a DFO onStop is one of this mandatory functions. onStop is triggered when a microservice is removed. The method body can be left blank (i.e. you don't need any special startup/teardown logic) The only strict requirement is for the method to be there.","title":"onStop(address)"}]}